# SEUYacc

## 项目要求

**从cYacc.y文件生成cYacc.c**

- Yacc输入文件的解析
- 文法到对应LR(1)文法的下推自动机的构造
- LR(1)文法的下推自动机到相应分析表的构造
- LR(1)总控程序的构造（查表程序）
- 生成cYacc.c
- 生成语法树（MiniC 程序） 多叉树，图
- 文法解析、下推自动机构造、分析表构建、总控程序构造、最终生成 `.c` 文件以及语法树&图生成

**提交：**

- 课程设计报告：按模板要求
- 测试输入：lex、yacc文件，输出c文件和exe文件**（根据提供的规则实现词法分析器+语法分析器并封装）**
- 测试输入：MiniC程序，输出语法树、语义分析结果等**（输入C程序，输出语法分析的结果）**
- 每个小组一个总的PPT，介绍项目总体情况
- 每个组员准备一个PPT，介绍自己的工作

## MinC

## 词法分析器LEX（编写一个词法分析器）

**c99.l**:定义了词法分析的规则

需要根据规则编写词法分析器

## 语法分析器Yacc（编写一个语法分析器）

### Yacc文件解析



**c99.y**:token声明、语法规则、表达式规则、语句规则、数据类型和函数声明规则、错误处理

- 从 Yacc 规则中的 `%token` 部分可以提取出终结符
- 提取非终结符：所有产生式的左侧符号都是非终结符。
- 生成产生式

**规则分析器YaccParser：**

- 终结符
- 非终结符

- 产生式列表:将文法中的符号（终结符和非终结符）转换为整数表示（为符号分配ID）

#### 数据结构定义

```{c++}
struct Producer {
	string left;//产生式左端
	vector<string> right;//产生式右端
};
```

终结符&非终结符：哈希表存储string与唯一ID的映射关系

#### 功能实现

将c99.y文件视为三个组成部分：开头分别为

- %token（生成终结符）
- %%（读取产生式）
- %%（错误处理，不管此部分）

按行读取文件：先得到定义终结符（生成对应ID），再得到产生式

分析产生式：补充终结符表，并得到非终结符表（均生成对应ID）

**使用整数表示终结符和非终结符**

-1：代表空集

终结符：从300开始自增

非终结符：从500开始自增

```{c++}
extern unordered_map<string, int> terminal;
extern unordered_map<string, int> nonterminal;
extern unordered_map<int, string> IdTerminal;
extern unordered_map<int, string> IdNonterminal;
string id2symbol(int ID);
int symbol2id(string symbol);
```

存储string与ID的双向映射关系

判断终结符/非终结符是否存在的函数

```{c++}
bool isTerminal(string s);
bool isNonterminal(string s);
bool isTerminalid(int id);
bool isNonterminalid(int id);
```



### 由文法构造LR(1)DFA

–创建0号产生式，产生式右部为规定的起始非终结符，点在起始非终结符左部

–创建0号状态，将0号产生式放入其中，随后对该状态进行状态内的扩展并入队列

•当队列不为空时，从队列中取出未处理状态s，对其进行如下处理：

–对状态s进行状态间扩展，求s所有的发出边和对应的新状态。遍历所有发出边：

–对由该发出边移进后产生的新状态求状态内的扩展

–遍历所有已经建立的状态，若状态扩展后与其中某状态s’相同，则不新建状态

–否则新建状态s’，并将其入队

–连接边s->s’

#### 数据结构定义

**LR项**

```{c++}
struct LRItem {
	int positionInt = 0;//点的位置
	int gramarInt = -1;//产生式标号
	int predictiveSymbol;//预测符
};
```

**LR状态项**

```{c++}
struct LRState {
	int numberInt = -1;//状态号
	unordered_map<int, int> edgesMap;
	//<发出边上符号，状态号>
	unordered_set<LRItem> LRItemsSet;
};
```

**LRDFA**

```{c++}
struct LRDFA{
	int startState = 0;
	vector<LRState > statesVec;  //存储所有的LRState，状态集
};
```



#### 状态内部扩展（同一项）

**需要实现的内容：非终结符first集算法、状态扩展算法**

–新建空队列，并将状态s的所有产生式加入队列

当队列不为空时，取出队列头部的LR项r，判断其右侧项；

若为非终结符，补充产生式到队列

**计算First集`first(βa)`**：

- 在扩展过程中，我们需要计算`βa`的First集，其中`β`是符号`B`后面的部分（即`B`后面的符号），而`a`是我们正在处理的输入符号。
- `first(βa)`表示从符号`β`开始，接下来可能会出现哪些终结符。我们需要去掉`ε`（空串），因为空串不会影响预测符集的生成。

- 计算出的`first(βa)`会用来生成LR项的**预测符集**，这是一个表示可能会出现在输入中的符号集合。
- 如果`first(βa)`包含空串（`ε`），则意味着`B`后面的部分可能为空，此时我们需要特别处理。
- 通过计算出的预测符集，我们可以创建一个新的LR项目`r'`，这个项目将`B -> · γ`作为新的状态。

```{c++}

```



#### 状态之间扩展（图中补充新的状态）

**需要实现的内容：检测LR项点右移后应该加入的项集合（状态I方框）**

找到某状态中每个LR项r

•若r的点在产生式的最后，不做任何操作（结束）

•否则查看点后的符号s，将r的点右移，生成新项目并入相应的LR项集合中（更新状态）

#### 状态重复检查

### 测试用规则

1. S` ->S    

2. S ->CC

3. C->cC|d




### 将LR(1) DFA转化为LR (1)分析表

–对于每一个状态：

•先处理所有的移进情况，遍历所有发出边，将下一个移进的值记录在next对应位置中（状态基址+字符偏移量），

  约定移进的值大于0，而归约的值小于0

•对归约情况进行处理：

»判断是否是会产生归约的项

   对归约情况处理：

»在预测符下归约，文法开始符号产生式归约做特殊处理

»若该预测分析符所在位置已经有值，则根据优先级和结合性处理移进-归约、归约/归约冲突

### cYacc.c生成(语法分析结果)

**需要实现的内容：语法分析过程**

–定义符号栈、状态栈和语义栈;

–初始状态压入状态栈，初始符号$压入符号栈；

–读取当前token;

–执行下列步骤直到结束

•令item为根据当前栈顶和读头下token查分析表得到的项

–如果item>0即表示移进

»将item压入状态栈；

»将token压入符号栈；读取下一个token

–如果item<0即表示归约

»判断产生式p是否为-1，若为-1则代表规约0号产生式，分析结束

»根据item查表得到产生式p，进行相关处理

–如果item=0表示无法继续分析，报错处理。

### 生成语法树（MiniC 程序） 多叉树

**需要实现的内容：给定输入使用graphviz输出语法树**

